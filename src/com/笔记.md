# 笔记

## 026

### 题目

给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



判题标准:

系统会用下面的代码来测试你的题解:

int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
如果所有断言都通过，那么您的题解将被 通过。



示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

示例 2：

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。


提示：

1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按 升序 排列

### 解析

该题目希望做到2件事

​	1：返回不重复元素的个数

​	2：nums数组的前面元素变成非重复的形式，后面的元素不用在意

​		如：[0,0,1,2,3,3,4] -> [0,1,2,3,4, , ]    [1,2,3,4,5,5,5,6] -> [1,2,3,4,5,6, , ]

count作为不重复元素的个数，因为至少存在一个，所以从1开始计数。

然后比较元素，这里就采取快慢指针的方式，left作为慢指针（从0开始），right作为快指针（从1开始），依次比较值是否相同，如果不相同，则将right指向的值赋给left的下一个指针，然后总数量count+1

大致代码如下：

```java
// 为空或元素为0就直接返回0
if(nums == null || nums.length == 0) return 0;
count = 1, left = 0, right = 1;
// 注意，这里需要=，因为最后一个元素可能跟倒数第二个不同，如果没有=会缺少数量
while(right<=nums.length-1) {
    // 如果值不相同，就将right指向的值赋给left的下一个指针，然后总数量count+1
    if(nums[left] != nums[right]) {
        nums[++left] = nums[right];
        count++;
    }
    // 无论值是否相同，right都需要指向下一个节点
    right++;
}
```



## 095

### 题目

不同的二叉搜索树：

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

### 解析

首先，节点遍历出来的顺序是确定的，可以假设中序遍历后为【1,2,3】这样的顺序，那么所产生的树就为以下5种：

![image-20230102173349781](C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20230102173349781.png)

这种就是n=3的情况，那么n=2时，只能产生如下2种树结构：

![image-20230102173539023](C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20230102173539023.png)

那么n=1的时候就只能有1种，而n=0时，也只存在1种确认没有节点的情况，

**即n=0和n=1时结果都为1**。

然后再分析n=3时的树：

​	1.当节点1作为根节点时，左子节点是不能有任何节点存在的，那左边就相当于n=0的情况，而右边由2个节点组成，那就相当于n=2的情况

​	2.当节点2作为根节点时，左子节点只能有1个节点，即n=1，右子节点也一样

​	3.当节点3作为根节点时，左子节点由2个节点产生，即n=2，右子节点为n=0

当**节点i**作为根节点时，设左子节点结果数为a、右子节点结果数为b，节点i（1<=i<=n）产生的总结果数为f(i)，设n个节点产生的结果数为G(n)，那么

f(i) = axb

G(n) = f(1) + f(2) + ... + f(n)

a=G(i-1)，b=G(n-i)

所以公式为：

**G(n) = G(0)xG(n-1) + G(1)xG(n-2) + G(2)xG(n-3)+.....+G(n-1)xG(0)**

再通过计算验证一下：

​	G(2) = G(0)xG(1) + G(1)xG(0) = 1x1 + 1x1 = 2

​	G(3) = G(0)xG(2) + G(1)xG(1) + G(2)xG(0) = 1x2 + 1x1 + 2x1 = 5

​	G(4) = G(0)xG(3) + G(1)xG(2) + G(2)xG(1) + G(3)xG(0) = 1x5 + 2x1 + 1x2 + 5x1 = 14



